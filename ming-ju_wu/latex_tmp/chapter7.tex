\chapter{Conclusions and Future Work}
\label{ch:7}

\section{Conclusions}

This dissertation describes a novel OS state pausing approach that can be used to allow OS running on real computer hardware to be co-simulated with virtually simulated storage device in the discrete-time domain. Due to reason that the co-simulation of the virtual storage device and the OS is happening in the discrete-time domain, the speed of the entire simulation process is not limited to the real-time speed. This means that: (1) When needed, the state of the OS can be frozen to wait for the processing of the virtual storage device. The storage device simulator can take as long as it needs for simulating the storage device without affecting the performance of the virtual storage device as perceived by the OS. This allows storage devices of arbitrarily speeds to be easily simulated without being constraint by the performance of the available hardware. (2) When the entire system is simply waiting in the CPU idle loop for a certain amount of time to pass by, the simulation process can be fast-forwarded to a future time point by advancing the current system time directly. This allows the simulation to be conducted at faster than real-time speeds.

Two co-simulation environments are built using the proposed co-simulation methodology. The first environment is a full-system co-simulator that allows storage subsystem equipped with simulated storage device to be evaluated using realistic workloads generated by real application programs running on real hardware. With the CPU idle loop time-skipping feature, the proposed full-system simulator is able to conduct experiments in faster than real-time speeds. Simulation speeds of up to 45$\times$ are observed in the experimental results. The second environment is a storage device emulator that allows the studying of the performance of real computer systems when different storage devices are available. Experimental results show that the performances measured using the proposed storage device emulator are within 2\% differences compared to the results from the reference system. 

\section{Directions for Future Research}

\subsection{Support for Emulating Multiple Storage Devices}

An improvement that can be made to the proposed co-simulation environment is to add support for emulating multiple storage devices. When multiple disks can be emulated, storage subsystem characteristics such as the performance of online RAID rebuild algorithms can be studied. For example, realistic workloads and be generated toward a degraded RAID array while it is performing the rebuild operations.

\subsection{Pausing the System State from a Lower Level}

The key idea that enables the co-simulation of virtual storage device and physical computer system in this dissertation is the ability to pause the state of the OS. The system state disturbances that can be caused by the OS state pausing is relatively small when compared to the frequency at which the I/O requests are being serviced. However, as the speed of the simulated virtual storage device is raised, it is possible that the disturbances caused by OS state pausing will become more apparent. In this case, if the pausing of the OS state can be performed with special mechanisms provided by the underlying hardware, then it is possible that the system state disturbance caused by the OS state pausing can be further reduced.

One possible approach is to control the digital clocks of the underlying circuit hardware. For example, instead of emulating the virtual storage device to the OS at the block device driver level, the virtual storage device can be simulated at the control registers level. Whenever I/O requests from the simulated storage device are submitted to the storage device simulator through the control registers, the state of the system is paused by stopping the clocks to the relevant hardware logics. Although for ASIC SoC devices it is probably not possible to request the underlying hardware to freeze and resume its state at the digital circuit's level, it might be possible to achieve this for systems running on FPGA devices with minimal design modifications. SoC chip vendors, such at MediaTek, are using FPGA devices for pre-silicon testing and validation. Open source full-system SoC projects, such as LEON~\cite{wiki:LEON}, also enable the entire computer system to be run on FPGA devices. It would be interesting to be able to implemented the concept of OS state pausing at a lower level on those systems to allow the physical computer system to be able to be co-simulated with virtual I/O devices that have much shorter operation times. In this case, the I/O devices that can be co-simulated is not limited to storage devices. For example, a virtual network interface can be simulated to the physical computer system and the behaviors of the connected network can be simulated using discrete network simulators such as NCTUns~\cite{Wang:2007}.

\subsection{Simulating Thermal Behaviors of the Target System}

The important factor that affects the prediction accuracy of the proposed storage device emulator is the disturbances that are introduced by the OS state pausing. In order to produce accurate prediction results, the system state difference between before and after OS state pausing should be small. One factor that the proposed storage device emulator currently does not take into account is the thermal effects of the target system. In some systems, the CPU might be throttled as to control the temperature of the SoC. However, due to the pausing made to the OS and the workload generated by the emulator kernel, the thermal dissipation pattern of the system with the proposed storage device emulator will be different from the pattern of the original unmodified system. Therefore, if the target system has some sort of thermal control enabled, then the temperature difference introduced by the proposed storage device emulator will lead to different system behaviors. In an other words, if the temperature of the SoC is considered as part of the system state, then the disturbance introduced by the OS state pausing will be large and will lead to inaccurate prediction results.

One possible solution for the thermal related system state disturbance discussed above is to introduced virtually simulated thermal sensors to the OS. Instead of reading the SoC temperature from the actual physical thermal sensors, the thermal behavior of the SoC is modeled and feed to the OS. During simulation, the temperature of the physical SoC is sufficiently cooled so that it never overheat. The simulated thermal readings of the SoC is then used as the reference for throttling the speed of the SoC. For example, assuming that the CPUs are the most relevant thermal sources of the SoC, then from the observing the workload levels of the CPUs we might be able to get a rough prediction of the temperature of the SoC. If the thermal characteristics of the SoC can be simulated in enough detail and used in place of the physical sensor readings, then the problem of system state disturbance introduced by the OS state pausing could be mitigated.

\subsection{Explicitly Control the Advancement of System Time}

In the current virtual storage device and real computer system co-simulation design, the system time is advancing continuously while the OS is in the running mode. A feature that can be introduced is to have the co-simulation environment explicitly control the advancement of the system time. When the advancement of the system time is explicitly controlled, the performance characteristics of the underlying CPU and memory subsystems will no longer affect the performance of the system as perceived by the OS. With this kind of simulation model, the co-simulation environment can be used as a platform invariant I/O workload generator. That is, regardless of the CPU speed of the host system that the co-simulation environment runs on, the generated I/O workloads toward the simulated storage device will be the same. The resulting platform invariant full-system I/O workload generator can be used as way for developers to explicitly described and exchange I/O test patterns.

One possible design for explicitly controlling the advancement of the system time in the co-simulation environment is to never advance the system without explicit request. The CPU in the co-simulation environment behaves as if it is infinitely fast when no explicit time advancement requests are made to the timekeeping infrastructure. The code paths in the system, including the code paths belongs to the OS and the application programs, need to explicitly request for time advancement if it wants to simulate that a block of CPU instructions has taken some amount of time to execute. In a multitasking environment, process context switch will occur when enough time advancements have been accumulated and that it is time for the scheduling tick to happen. Another possible scenario for process context switch is when the process voluntarily releases the usage of the CPU due to blocking on a resource or sleeps for a certain amount of time. In the first case, the process will be rescheduled again when the blocking condition is fulfilled. For example, if the blocking is due to waiting for an I/O response from the simulated storage device, then when the I/O response is finally return in a future system time the process will be woken up again. In the second case, the process will come out of the sleep when the system time is explicitly advanced in enough amount. 

Note that if the system is running some I/O benchmarks, then when the CPU enters the CPU idle loop, it should be able to determine a future system time point to advance to. The future system time point could either be the wakeup time of a process or the I/O completion time of the next I/O response. If there is no future time point to advance to, then we know that the simulation process is complete.

I have implemented and tested a preliminary implementation of the explicit system time control design as discussed above. One area that needs special attention is when the code path relies on busy loop to wait for a certain amount of time to pass by. In this case, because the system will not be advancing automatically and the CPU behave as if it were infinitely fast, the busy loop will never ends. It is required to make explicit requests for system time advancements in these time waiting busy loops. Another scenario that requires special attention is when polling based condition checks are used for synchronizing between two processes. Because the periodic scheduler tick responsible for process context switch will not happen when the CPU is busy polling (and thus the system time is not advancing), a busy polling process will occupy the CPU forever and preventing the system state from making progress. One solution is to manually identify these busy polling code paths and insert cooperative rescheduling requests inside the polling loops.
